//
//		DataConv.h
//
//		通信用データ変換関数
//
//		'08/10/08	Ver 1.00	初版                                      by iwakura
//		'08/12/10	Ver 1.00.1	cppファイルに一部移行                     by iwakura
//		'09/04/09	Ver 1.01	ConvRadTo2Byte, Dec2ByteToRad 関数を追加  by iwakura
//		'12/05/03	Ver 1.02	Conv1To2Byte, Dec2ByteTo1 関数を追加      by iwakura
//
//

#ifndef INCLUDED_DATACONV_H
#define INCLUDED_DATACONV_H

#include "StandardDef.h"

struct PropoData;

//*******************************************************************************
//	角度値を5バイトのデータに変換する．
//
//	引数：
//		degree - 角度値．-180〜180の範囲で指定．
//
//	Note:
//		緯度経度の角度情報の保存には5バイトで十分．
//		発生する距離の誤差は大きく見積もっても 100マイクロメートル．
//*******************************************************************************
inline _SQWORD ConvDegTo5Byte(double degree)
{
	return (_SQWORD)((degree + 180.0) * 3054198966.0444444444444444444444) & (_SQWORD)0x000000FFFFFFFFFF;
}

//*******************************************************************************
//	5バイトのデータから角度値を復元する
//
//	引数：
//		data - ConvDegTo5Byteで変換した5バイトのデータ
//*******************************************************************************
inline double Dec5ByteToDeg(_SQWORD data)
{
	return (data & (_SQWORD)0x000000FFFFFFFFFF) * 3.274180926382541656494140625e-10 - 180.0;
}

//*******************************************************************************
//	角度値を4バイトのデータに変換する．
//
//	引数：
//		degree - 角度値．-180〜180の範囲で指定．
//*******************************************************************************
inline _SDWORD ConvDegTo4Byte(double degree)
{
	return (_SDWORD)(degree * (0x7FFFFFFF / 180.0));
}

//*******************************************************************************
//	4バイトのデータから角度値を復元する
//
//	引数：
//		data - ConvDegTo4Byteで変換した4バイトのデータ
//*******************************************************************************
inline double Dec4ByteToDeg(_SDWORD data)
{
	return (data * (180.0 / 0x7FFFFFFF));
}

//*******************************************************************************
//	角度値を2バイトのデータに変換する．
//
//	引数：
//		degree - 角度値．-180〜180の範囲で指定．
//
//	Note:
//		最大誤差は約0.00549
//*******************************************************************************
inline _SWORD ConvDegTo2Byte(double degree)
{
	return (_SWORD)(degree * 182.04444444444444444444444444444);
}

//*******************************************************************************
//	2バイトのデータから角度値を復元する
//
//	引数：
//		data - ConvDegTo2Byteで変換した2バイトのデータ
//*******************************************************************************
inline double Dec2ByteToDeg(_SWORD data)
{
	return data * 0.0054931640625;
}

//*******************************************************************************
//	ラジアン単位の角度値を2バイトのデータに変換する．
//
//	引数：
// 		radian - 角度値．-π〜πの範囲で指定．
//
//	Note:
//		最大誤差は約0.0000959
//*******************************************************************************
inline _SWORD ConvRadTo2Byte(double radian)
{
	return (_SWORD)(radian * 10430.378350470452724949566316381);
}

//*******************************************************************************
//	2バイトのデータからラジアン単位の角度値を復元する
//
//	引数：
//		data - ConvRadTo2Byteで変換した2バイトのデータ
//*******************************************************************************
inline double Dec2ByteToRad(_SWORD data)
{
	return data * 9.5873799242852576857380474343247e-5;
}

//*******************************************************************************
//	±1の範囲のdouble型データを2バイトのデータに変換する
//
//	引数：
//		value - double型のデータ
//
//	Note:
//		最大誤差は約0.0000305
//*******************************************************************************
inline _SWORD Conv1To2Byte(double value)
{
	return (_SWORD)(value * 32768.0);
}

//*******************************************************************************
//	2バイトのデータから±1の範囲の値を復元する
//
//	引数：
//		data - Conv100To2Byteで変換した2バイトのデータ
//*******************************************************************************
inline double Dec2ByteTo1(_SWORD data)
{
	return data / 32768.0;
}

//*******************************************************************************
//	±10の範囲のdouble型データを2バイトのデータに変換する
//
//	引数：
//		value - double型のデータ
//
//	Note:
//		最大誤差は約0.000305
//*******************************************************************************
inline _SWORD Conv10To2Byte(double value)
{
	return (_SWORD)(value * 3276.8);
}

//*******************************************************************************
//	2バイトのデータから±10の範囲の値を復元する
//
//	引数：
//		data - Conv10To2Byteで変換した2バイトのデータ
//*******************************************************************************
inline double Dec2ByteTo10(_SWORD data)
{
	return data / 3276.8;
}

//*******************************************************************************
//	±100の範囲のdouble型データを2バイトのデータに変換する
//
//	引数：
//		value - double型のデータ
//
//	Note:
//		最大誤差は約0.00305
//*******************************************************************************
inline _SWORD Conv100To2Byte(double value)
{
	return (_SWORD)(value * 327.68);
}

//*******************************************************************************
//	2バイトのデータから±100の範囲の値を復元する
//
//	引数：
//		data - Conv100To2Byteで変換した2バイトのデータ
//*******************************************************************************
inline double Dec2ByteTo100(_SWORD data)
{
	return data / 327.68;
}

//*******************************************************************************
//	±1000の範囲のdouble型データを2バイトのデータに変換する
//
//	引数：
//		value - double型のデータ
//
//	Note:
//		最大誤差は約0.0305
//*******************************************************************************
inline _SWORD Conv1000To2Byte(double value)
{
	return (_SWORD)(value * 32.768);
}

//*******************************************************************************
//	2バイトのデータから±1000の範囲の値を復元する
//
//	引数：
//		data - Conv1000To2Byteで変換した2バイトのデータ
//*******************************************************************************
inline double Dec2ByteTo1000(_SWORD data)
{
	return data * (1.0 / 32.768);
}

//*******************************************************************************
//	±10000の範囲のdouble型データを3バイトのデータに変換する
//
//	引数：
//		value - double型のデータ
//
//	Note:
//		最大誤差は約0.0012
//*******************************************************************************
inline _SDWORD Conv10000To3Byte(double value)
{
	return (_SDWORD)((value + 10000.0) * 838.8608) & (_SDWORD)0xFFFFFF;
}

//*******************************************************************************
//	3バイトのデータから±10000の範囲の値を復元する
//
//	引数：
//		data - Conv10000To3Byteで変換した3バイトのデータ
//*******************************************************************************
inline double Dec3ByteTo10000(_SDWORD data)
{
	return (data & (_SDWORD)0xFFFFFF) / 838.8608 - 10000.0;
}

//*******************************************************************************
//	プロポデータを5バイトのデータに変換する
//
//	引数：
//		pPropo	プロポデータのポインタ
//
//	Note:
//		スティック情報9ビット×4 + スイッチ情報4ビット
//		ビットフィールドは処理系に依存するので使わない
//*******************************************************************************
#ifdef __cplusplus
_UQWORD ConvPropoPacket(const PropoData* pPropo);
#endif

//*******************************************************************************
//	5バイトのデータからプロポデータを復元する
//
//	引数：
//		data   - ConvPropoPacketで変換した5バイトのデータ
//		pPropo - 復元したデータの格納先
//*******************************************************************************
#ifdef __cplusplus
void DecPropoPacket(_UQWORD data, PropoData* pPropo);
#endif

//*******************************************************************************
//	年月日データを2バイトのデータに変換する
//
//	引数：
//		Year  年の下2桁の値 （例：2014年 → 14）
//		Month 月
//		Day   日
//*******************************************************************************
inline _UWORD ConvDateTo2Byte(_UBYTE Year, _UBYTE Month, _UBYTE Day)
{
	return ((Year & 0x3F) << 9) | ((Month & 0xF) << 5) | (Day & 0x1F);
}

//*******************************************************************************
//	2バイトのデータから年月日に変換する
//
//	引数：
//		data   ConvDateTo2Byteで変換した2バイトのデータ
//		pYear  年の下2桁の値 （例：2014年 → 14）
//		pMonth 月
//		pDay   日
//*******************************************************************************
inline void Dec2ByteToDate(_UWORD data, _UBYTE* pYear, _UBYTE* pMonth, _UBYTE* pDay)
{
	*pYear  = (data >> 9) & 0x3F;
	*pMonth = (data >> 5) & 0x0F;
	*pDay   = (data     ) & 0x1F;
}

//*******************************************************************************
//	年月日時分秒データを4バイトのデータに変換する
//
//	引数：
//		Year   年の下2桁の値 （例：2014年 → 14）
//		Month  月
//		Day    日
//      Hour   時
//      Minute 分
//      Second 秒
//*******************************************************************************
inline _UDWORD ConvDateAndTimeTo4Byte(_UBYTE Year, _UBYTE Month, _UBYTE Day, _UBYTE Hour, _UBYTE Minute, _UBYTE Second)
{
	return Year      * ((_UDWORD)60*60*24*31*12) +
		   (Month-1) * ((_UDWORD)60*60*24*31) +
		   (Day-1)   * ((_UDWORD)60*60*24) +
		   Hour      * (60*60) +
		   Minute    * 60 +
		   Second;
}

//*******************************************************************************
//	4バイトのデータを年月日時分秒を復元する
//
//	引数：
//		pYear   年の下2桁の値 （例：2014年 → 14）
//		pMonth  月
//		pDay    日
//      pHour   時
//      pMinute 分
//      pSecond 秒
//*******************************************************************************
inline void Dec4ByteToDateAndTime(_UDWORD data, _UBYTE* pYear, _UBYTE* pMonth, _UBYTE* pDay, _UBYTE* pHour, _UBYTE* pMinute, _UBYTE* pSecond)
{
	_UDWORD tmp;
	tmp = data / 60; *pSecond = (_UBYTE)(data - tmp * 60);     data = tmp;
	tmp = data / 60; *pMinute = (_UBYTE)(data - tmp * 60);     data = tmp;
	tmp = data / 24; *pHour   = (_UBYTE)(data - tmp * 24);     data = tmp;
	tmp = data / 31; *pDay    = (_UBYTE)(data - tmp * 31 + 1); data = tmp;
	tmp = data / 12; *pMonth  = (_UBYTE)(data - tmp * 12 + 1); data = tmp;
	*pYear = (_UBYTE)(data);
}

// 20140925 TCS.Y.Nakamura ADD_S
#include <string.h>
//*******************************************************************************
//	2バイトの秒データから時間、分、秒データに変換する
//
//	引数：
//		time    変換対象データへのポインタ
//		pHour   時間へのポインタ
//		pMinute 分へのポインタ
//		pSecond 秒へのポインタ
//		GetByte 変換対象サイズ
//*******************************************************************************
inline int ConvSecToHMS(void* time, _UDWORD* pHour, _UBYTE* pMinute, _UBYTE* pSecond, int GetByte)
{
	int b_time = 0;
	int *temp = (int*)time;
	
	// パラメータチェック
	if((NULL == time) || (NULL == pHour) || (NULL == pMinute) || (NULL == pSecond)
		|| (sizeof(b_time) <= GetByte)){
		return -1;
	}
	
	// 指定サイズ分、データコピー
	memcpy(&b_time, temp, GetByte);
	
	*pHour = b_time / 3600;
	*pMinute = (b_time % 3600) / 60;
	*pSecond = b_time % 60;
	
	return 0;
}
// 20140925 TCS.Y.Nakamura ADD_E

//*******************************************************************************
//	GPS週、GPS週秒のデータを2バイトのデータに変換する
//
//	引数：
//		GpsWeek       GPS週
//      GpsWeekSecond GPS週秒 (小数点以下も含む)
//
//  備考：
//      2042年頃に計算結果がオーバーフローします
//      時間解像度は0.2秒
//*******************************************************************************
inline _UDWORD ConvGpsTimeTo4Byte(_UWORD GpsWeek, float GpsWeekSecond)
{
	return (GpsWeek - 1800) * 3024000 + (_UDWORD)(GpsWeekSecond * 5);
}

//*******************************************************************************
//	4バイトのデータからGPS週、GPS週秒のデータを復元する
//
//	引数：
//		GpsWeek       GPS週
//      GpsWeekSecond GPS週秒 (小数点以下も含む)
//
//  備考：
//      2042年頃に計算結果がオーバーフローします
//*******************************************************************************
inline void Dec4ByteToGpsTime(_UDWORD data, _UWORD* pGpsWeek, float* pGpsWeekSecond)
{
	_UWORD tmp = (_UWORD)(data / 3024000);
	*pGpsWeek = tmp + 1800;
	*pGpsWeekSecond = (data - (tmp * 3024000)) * 0.2f;
}

#endif